%!TEX root=../document.tex

\section{Ergebnisse}
\label{sec:Ergebnisse}

\subsection{Installation und Testdurchlauf von Ori}
\label{subsec:Installation und Testdurchlauf von Ori}
Für die Übungsdurchführung wird mithife von Vagrant eine 'ubuntu/wily64'-Box bereitgestellt. Das dazugehörige Vagrantfile befindet sich in unserem Repository. \cite{repo} Zum Ausprobieren wurde dazu noch eine Debian-VM mit LXDE aufgesetzt, um die Funktionalität optimal testen zu können. Auf der Herstellerseite sind auch einige der wichtigsten Kernaspekte von OriFS aufgelistet: 

\begin{itemize}
	\item Peer-to-Peer \newline
	'Ori operates peer-to-peer among your devices and uses existing secure communication channels such as SSH to transfer your data.'
	\item Work Offline \newline
	'In today's world we often are moving around with intermittent network connectivity and we want to access our data when we board a plane or travel to the office.'
	\item Secure \newline
	'Ori can verify the authenticity of your data and ensure it has not been tampered with. Data is transfered over SSH. Device discovery and automatic synchronization uses a shared secret to initiate transfers.'
	\item Instant Access \newline
	'Instantly mount remote file systems and start working while you synchronize data in the background.' \cite{OrifsStanford}
\end{itemize}

\subsubsection{Fehler bei Installation über Ubuntu PPA}
\label{subsubsec:Fehler bei Installation über Ubuntu PPA}
Die Installationsanleitung auf der Seite der Hersteller \cite{OrifsStanford} ist falsch. \newline
\begin{lstlisting}[frame=single, language=bash, caption=Anleitung zur Installation laut Hersteller - fehlerhaft]
add-apt-repository ppa:ezyang/ppa
apt-get update
# Hier entsteht der Fehler: 404 Not Found
# Einige Indexdateien konnten nicht heruntergeladen werden. 
# Sie wurden ignoriert oder alte an ihrer Stelle benutzt.
apt-get install ori # Funktioniert nicht!
\end{lstlisting}
Hierbei kommt es zu einem 404-Fehler, die Informationen zur Installation sind nicht mehr aktuell. Diese Paketquelle ist nicht mehr vorhanden, da sie bereits in den Standard-Paketquellen vorhanden sind.

\clearpage

\subsubsection{Installation in Ubuntu}
\label{subsubsec:Installation in Ubuntu}
Im Zuge dessen ist es regelrecht einfach, OriFS zu installieren. Folgende Befehle sind notwendig:
\begin{lstlisting}[frame=single, language=bash, caption=Anleitung zur Installation]c
apt-get update
apt-get install ori
\end{lstlisting}
Daraufhin ist OriFS unter Ubuntu vollständig installiert.

\subsubsection{Kompilieren und Installation 'from source' mit SCons}
\label{subsubsec:Kompilieren und Installation 'from source' mit SCons}
OriFS ist laut den Herstellern verfügbar für FreeBSD, OS X, Arch Linux und Ubuntu.
Es gibt aber natürlich auch eine andere Art, das Programm zu erlangen: Direkt über den frei zugänglichen Quelltext kompilieren und installieren. Dafür sind folgende Schritte notwendig:
\begin{lstlisting}[frame=single, caption=Anleitung zur Installation 'from source']
apt-get update

apt-get install scons build-essential pkg-config -y
apt-get install libboost-dev uuid-dev libfuse-dev libevent-dev libssl-dev -y

wget https://bitbucket.org/orifs/ori/downloads/ori-0.8.1.tar.xz
tar xvfJ ori-0.8.1.tar.xz
cd ori-0.8.1

scons

scons PREFIX=/usr/local/ install
\end{lstlisting}
Hierbei wird unter anderem SCons als Build-Tool verwendet. Der Installationspfad '/usr/local' ist daher vorzuziehen, weil hier vom Administrator Programme und Dateien ablegt werden können, die von der entsprechenden Distribution des jeweiligen Systems unabhängig installiert worden sind, wie etwa selbstkompilierte oder unabhängig von der Distribution heruntergeladene Programme. 

\subsubsection{OriFS-Testfälle ausführen}
\label{subsubsec:OriFS-Testfälle ausführen}
Im entpackten Sourcecode-Archiv sind auch die von uns gewünschten Testfälle enthalten. Folgendes Skript führt diese aus:
\begin{lstlisting}[frame=single, language=bash, caption=Erster Versuch Testfälle]
./runtests.sh
\end{lstlisting}
Nach nur wenigen Testfällen schlägt der Lauf fehl. Eine Recherche ergibt, dass dies keineswegs ein Einzelfall ist. Das mitgelieferte README-File, zitiert: \newline
\textit{'There are multiple unit tests available inside the build directory.  The
end-to-end tests are in ongoing development and only about half of them are
expected to run reliably.  In a future release the tests will be improved to
make it easier to run.'} \newline
\clearpage
Die in der Aufgabenstellung beschriebene Hilfestellung schafft Abhilfe. \cite{OrifsBitbucket} Im folgenden Schritt wird im extrahierten Archiv die Datei \textit{runtests\_config.sh} angelegt. Das File beinhaltet folgende Zeilen:
\begin{lstlisting}[frame=single, language=bash, caption=Inhalt runtests\_config.sh]
# Required for Mac OS X and FreeBSD only (comment out on Linux machines)
# export UMOUNT="umount"

# Not updated to new CLI

HTTP_CLONE="no"

HTTP_PULL="no"

MERGE="no"

MOUNT_WRITE="no"

MOUNT_WRITE_PYTHON_MT="no"
\end{lstlisting}
Die Unit-Tests, die nicht funktionieren, werden übersprungen. Bei Fehlern muss der Ordner \textit{tempdir} sowie die Testrepositories in dem im Home-Verzeichnis versteckten Ordner \textit{~/.ori/<name>.ori} gelöscht werden. Ein SSH-Public Key muss ebenso angelegt werden, um ein passwortloses Anmelden zu ermöglichen. Die Tests mit der Numer 54 und 61 resultieren in einem Syntaxfehler. Das Package ist nicht auf dem Rechner vorhanden, liegt daher nicht an OriFS. Nach ausgedehntem Troubleshooting und Lesen der Fehlermeldung konnte auch dieser Fehler behoben werden. Die Files im Ordner \textit{ori\_tests}, \textit{53-mount-write-wget.sh} sowie \textit{61-mount-write-wget-mt.sh}, müssen ausgebessert werden. Die jeweils erste Zeile muss auf die aktuell installierte Version von \textit{wget} zeigen. In diesem Fall wurde der String auf \textit{wget-1.16.1} ausgebessert. Erst jetzt funktionieren die Tests ohne Probleme. Die Testfälle 01-05, 11-15, 30, 52-53, 60-61 wurden erfolgreich ausgeführt, 21-22, 35, 51, 62 wurden übersprungen.

\subsection{Einsatz / Dokumentation der Ori API}
\label{subsec:Einsatz / Dokumentation der Ori API}
Jeder der angeschriebenen Befehle wurde ausgeführt und dokumentiert. Jeglicher Ausgangspunkt in der Konsole ist das Verzeichnis \textit{/home/mweinberger}.

\subsubsection{newfs - Anlegen eines Filesystems}
\label{subsubsec:newfs - Anlegen eines Filesystems}
Das Erstellen eines Dateisystems ist wie anzunehmen der erste Schritt bei OriFS. Mithilfe des Befehls \textit{ori} wird somit eines erstellt, und im Anschluss mit einem leeren, neu erstellten Verzeichnis eingehängt.
\begin{lstlisting}[frame=single, caption=newfs]
ori newfs dezsys

mkdir dezsys

orifs /home/mweinberger/dezsys
\end{lstlisting}

\subsubsection{removefs - Löschen eines Filesystems}
\label{subsubsec:removefs - Löschen eines Filesystems}
Natürlich lässt sich das Dateisystem auch wieder löschen, ebenso mit dem \textit{ori}-Befehl, es muss lediglich ausgehängt sein. Das vorher erstellte Verzeichnis kann auch gelöscht werden, sofern es nicht mehr benötigt wird.
\begin{lstlisting}[frame=single, caption=removefs]
umount /home/mweinberger/dezsys

ori removefs dezsys

rm -rf dezsys
\end{lstlisting}

\subsubsection{list - Lokale Dateisysteme auflisten}
\label{subsubsec:list - Lokale Dateisysteme auflisten}
Dieser Befehl listet alle lokalen Ori-Dateisysteme auf. Hier werden Remote-Repositories nicht berücksichtigt.
\begin{lstlisting}[frame=single, caption=list]
root@ubuntu-mweinberger:/home/mweinberger# ori list

Name                            File System ID
dezsys                          0868b64e-d0ec-4c2d-9230-3ce66f301136
\end{lstlisting}

\subsubsection{replicate - Eine lokale Repository-Replik anlegen}
\label{subsubsec:replicate - Eine lokale Repository-Replik anlegen}
Der Befehl \textit{replicate} lässt Ori-Dateisysteme auf andere replizieren. So lässt sich ein Repository in dem Sinne 'klonen'. Langsam wird es möglich, Ori effektiv als verteiltes Dateisystem einzusetzen. Es wird nur das Dateisystem erstellt, das Verzeichnis muss händisch erstellt und gemountet werden. Folgende Befehle sind notwendig:
\begin{lstlisting}[frame=single, caption=replicate]
ori replicate root@debian:dezsys_remote

mkdir dezsys_remote
orifs dezsys_remote
\end{lstlisting}

\clearpage

\subsubsection{snapshot - Einen Repository-Snapshot anlegen}
\label{subsubsec:snapshot - Einen Repository-Snapshot anlegen}
In Ori dient ein Snapshot dazu, Veränderungen im Filesystem zu erkennen und diese zu speichern sowie den Commit den Remote Hosts bereitzustellen, welche das Dateisystem replizieren. Snapshots können auch zur lokalen Versionierung verwendet werden, generell vereint der Befehl \textit{commit \& push} in einem. Hier ein Beispiel, wie ein Snapshot nach Veränderungen an Dateien aussieht inkl Commit ID.
\begin{lstlisting}[frame=single, caption=snapshot]
root@debian:/home/mweinberger/dezsys# ori snapshot EINS
Committed 04c457f7e77dc1831eacc564bb2714a34df5b265d46b4f9e2b697564bc3ad160

root@debian:/home/mweinberger/dezsys# echo "Hallo!" > testfile.txt

root@debian:/home/mweinberger/dezsys# ori snapshot ZWEI
Committed 8eeb2869203d968f6ae8eeb28b2714a34df5b265d46b8eeb2869203d968f6ae3
\end{lstlisting}
Die gespeicherten Zustände der Snapshots sind in Unterverzeichnissen (\textit{.snapshot}) abgelegt, weshalb ein 'Rollback' zu früheren Zuständen sehr einfach ist (herauskopieren). Ohne Veränderungen gibt der Befehl nur ein 'No changes' zurück, der restliche Vorgang wird abgebrochen.

\subsubsection{log - Eine Commit-History für das Repository}
\label{subsubsec:log - Eine Commit-History für das Repository}
Wie gewohnt sammelt der Log alle Veränderungen, die vom User ausgegangen sind. Ein Beispiel eines Logs wird hier gezeigt:
\begin{lstlisting}[frame=single, caption=log]
root@debian:/home/mweinberger/dezsys# ori log

Commit:    04c457f7e77dc1831eacc564bb2714a34df5b265d46b4f9e2b697564bc3ad160
Parents:   8df1610b6299e4bf086eae0cf473c12326ef49aeed6a3e4eed4656e3832660307
Tree:      6e9bad8eeb2869203d968f6aed02c4e79e913f6535094d8f512565bf1b8a1b58
Author:    root
Date:      Fri Apr 12 20:20:31 2016

Created snapshot 'Hallo.txt'.
\end{lstlisting}

\subsubsection{tip - Gibt den neuesten Commit aus}
\label{subsubsec:tip - Gibt den neuesten Commit aus}
Mit diesem Befehl lässt sich die aktuellste Commit ID ermitteln. Er muss jedoch in einem gemounteten Ori-Dateisystem ausgeführt werden.
\begin{lstlisting}[frame=single, caption=tip]
root@debian:/home/mweinberger/dezsys# ori tip

04c457f7e77dc1831eacc564bb2714a34df5b265d46b4f9e2b697564bc3ad160
\end{lstlisting}

\clearpage

\subsubsection{pull/checkout - Änderungen von einem Repository beziehen}
\label{subsubsec:pull/checkout - Änderungen von einem Repository beziehen}
Dieser Befehl ist nach Git-Ordnung eher als \textit{Fetch} zu verstehen. Alle (entfernten) Veränderungen müssen auch am lokalen Dateisystem sein. Mit \textit{pull} werden sie lediglich heruntergeladen, zurückgeliefert wird eine Commit ID. Solange bis der \textit{checkout}-Befehl mit genannter ID nicht ausgeführt wurde, sind die Files nicht im Verzeichnis vorhanden.
\begin{lstlisting}[frame=single, caption=pull]
ori pull

ori checkout 04c457f7e77dc1831eacc564bb2714a34df5b265d46b4f9e2b697564bc3ad160
\end{lstlisting}

\subsubsection{show - Repository-Informationen ausgeben}
\label{subsubsec:show - Repository-Informationen ausgeben}
\textit{show} liefert eine Menge an Informationen über das Repository. Eine mögliche Rückgabe, Struktur immer gleichbleibend:
\begin{lstlisting}[frame=single, caption=show]
root@debian:/home/mweinberger/dezsys# ori show

--- Repository ---
Root: /root/.ori/dezsys.ori
UUID: dc377ee5-79b5-406b-a844-60a8f480c1d3
Version: ORI1.1
HEAD: 04c457f7e77dc1831eacc564bb2714a34df5b265d46b4f9e2b697564bc3ad160
\end{lstlisting}

\subsubsection{status - Suche nach Veränderungen seit letztem Commit}
\label{subsubsec:status - Suche nach Veränderungen seit letztem Commit}
Wieder gibt es sehr große Parallelen zu Git: Der Befehl ist im Grunde genommen ein \textit{git status}, Ori hat jedoch eine andere Struktur. Auch dieser Befehl kann nur in einem gemounteten Ori-Dateisystem ausgeführt werden.
\begin{lstlisting}[frame=single, caption=status]
root@debian:/home/mweinberger/dezsys# ori status

A	/neues-file.txt
D	/geloeschtes-file.txt
M	/geaendertes-file.txt
\end{lstlisting}

\clearpage

\subsubsection{filelog - Anzeigen des Logs für ein spezifisches File}
\label{subsubsec:filelog - Anzeigen des Logs für ein spezifisches File}
\textit{ori filelog} ist in dem Sinne nur eine Erweiterung für \textit{ori log}. Auch dieser Befehl kann nur in einem gemounteten Ori-Dateisystem ausgeführt werden. Hier kann ein Filename als Parameter mitgegeben werden, welches im Repository mindestens einmal committed wurde. Nun werden alle Commits ausgegeben, bei denen das angegebene File involviert war. Als Beispiel:
\begin{lstlisting}[frame=single, caption=filelog]
root@debian:/home/mweinberger/dezsys# ori filelog dezsys.txt

Commit:    04c457f7e77dc1831eacc564bb2714a34df5b265d46b4f9e2b697564bc3ad160
Parents:   8df1610b6299e4bf086eae0cf473c12326ef49aeed6a3e4eed4656e3832660307
Tree:      6e9bad8eeb2869203d968f6aed02c4e79e913f6535094d8f512565bf1b8a1b58
Author:    root
Date:      Fri Apr 12 20:34:45 2016

Created snapshot 'neuen Text eingefuegt'.
\end{lstlisting}

\subsubsection{graft - Repository auf ein Anderes kopieren}
\label{subsubsec:graft - Repository auf ein Anderes kopieren}
Ori ermöglicht es auch, ein Repository quasi 'hard' auf das andere zu kopieren. Das Verzeichnis wird repliziert in das Verzeichnis des Ziels. Anzugeben sind lediglich Ausgangsrepository, also wovon kopiert werden soll, und das Zielrepository. Um eine aktuelle Version auf dem Zielrepository zu haben, muss nach jeder Veränderung des Ausgangsrepositorys der \textit{graft}-Befehl ausgeführt werden.
\begin{lstlisting}[frame=single, caption=graft]
ori graft dezsys dezsys-neu
\end{lstlisting}

\subsubsection{varlink - Varlink-Variablen verwalten}
\label{subsubsec:varlink - Varlink-Variablen verwalten}
Mithilfe des Befehls können die Varlink-Variablen ausgelesen, aufgelistet oder auch neu gesetzt werden. Die Ausgabe auf der Debian-VM ist leider weniger repräsentativ.
\begin{lstlisting}[frame=single, caption=varlink]
root@debian:/home/mweinberger/dezsys# ori varlink

Variable        Value                                                           
machtype        unknown                                                         
osname          unknown                                                         
domainname      (none)                                                          
hostname        debian
\end{lstlisting}

\subsubsection{merge - Mergen zweier HEADs}
\label{subsubsec:remote - Mergen zweier HEADs}
Hier gab es leider große Schwierigkeiten. Entweder wurde der Befehl falsch verwendet (obwohl wie richtig angewiesen mit Commit ID) oder er ist in der derzeitigen Version des Programms noch nicht sehr ausgereift. Es scheint so, als wäre das Dateisystem dadurch beschädigt worden, da auch andere Befehle plötzlich nicht mehr einsatzfähig sind und Fehlermeldungen werfen, und das reproduzierbar. Dieser Befehl wurde daher lieber übersprungen.
\begin{lstlisting}[frame=single, caption=merge]
root@ubuntu-mweinberger:/home/mweinberger/dezsys# ori merge 04c457f7e77dc1831eacc564bb2714a34df5b265d46b4f9e2b697564bc3ad160
merge failed with an unknown error!
\end{lstlisting}

\subsubsection{remote - Verwalten von Remoteverbindungen}
\label{subsubsec:remote - Verwalten von Remoteverbindungen}
\textit{ori remote} gibt es, um bei einer Replikation die Verbindungseinstellungen zu verwalten. Es ist ja beispielsweise gut möglich, dass sich eine IP-Adresse ändert. Umso wichtiger ist es, die Remote-Adresse ändern zu können.

\subsection{Gegenüberstellung}
\label{subsec:Gegenüberstellung}

%\begin{lstlisting}[frame=single, caption=Testcaption]
%
%\end{lstlisting}
%
%
%\begin{figure}[!h]
%	\begin{center}
%		\includegraphics[width=1.0\linewidth]{images/ldapadmin_main.png}
%		\caption{phpLDAPadmin Startseite}
%		\label{ldapadmin_main}
%	\end{center}
%\end{figure}